{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"TypeSystem TypeSystem is a comprehensive data validation library that gives you: Data validation. Object serialization & deserialization. Form rendering. 100% type annotated codebase. 100% test coverage. Zero hard dependencies. Requirements Python 3.6+ Installation $ pip3 install typesystem If you'd like you use the form rendering you'll also want to install jinja2 . $ pip3 install jinja2 Quickstart import typesystem class Artist ( typesystem . Schema ): name = typesystem . String ( max_length = 100 ) class Album ( typesystem . Schema ): title = typesystem . String ( max_length = 100 ) release_date = typesystem . Date () artist = typesystem . Nested ( Artist ) album = Album . validate ({ \"title\" : \"Double Negative\" , \"release_date\" : \"2018-09-14\" , \"artist\" : { \"name\" : \"Low\" } }) print ( album ) # Album(title='Double Negative', release_date=datetime.date(2018, 9, 14), artist=Artist(name='Low')) print ( album . release_date ) # datetime.date(2018, 9, 14) print ( album [ 'release_date' ]) # '2018-09-14' print ( dict ( album )) # {'title': 'Double Negative', 'release_date': '2018-09-14', 'artist': {'name': 'Low'}} \u2014 \u2b50\ufe0f \u2014 TypeSystem is BSD licensed code. Designed & built in Brighton, England.","title":"Introduction"},{"location":"#typesystem","text":"TypeSystem is a comprehensive data validation library that gives you: Data validation. Object serialization & deserialization. Form rendering. 100% type annotated codebase. 100% test coverage. Zero hard dependencies.","title":"TypeSystem"},{"location":"#requirements","text":"Python 3.6+","title":"Requirements"},{"location":"#installation","text":"$ pip3 install typesystem If you'd like you use the form rendering you'll also want to install jinja2 . $ pip3 install jinja2","title":"Installation"},{"location":"#quickstart","text":"import typesystem class Artist ( typesystem . Schema ): name = typesystem . String ( max_length = 100 ) class Album ( typesystem . Schema ): title = typesystem . String ( max_length = 100 ) release_date = typesystem . Date () artist = typesystem . Nested ( Artist ) album = Album . validate ({ \"title\" : \"Double Negative\" , \"release_date\" : \"2018-09-14\" , \"artist\" : { \"name\" : \"Low\" } }) print ( album ) # Album(title='Double Negative', release_date=datetime.date(2018, 9, 14), artist=Artist(name='Low')) print ( album . release_date ) # datetime.date(2018, 9, 14) print ( album [ 'release_date' ]) # '2018-09-14' print ( dict ( album )) # {'title': 'Double Negative', 'release_date': '2018-09-14', 'artist': {'name': 'Low'}} \u2014 \u2b50\ufe0f \u2014 TypeSystem is BSD licensed code. Designed & built in Brighton, England.","title":"Quickstart"},{"location":"examples/","text":"The following are examples of integrating typesystem against a Web framework. API validation & serialization from starlette.applications import Starlette from starlette.responses import JSONResponse from starlette.routing import Route import typesystem import uvicorn users = [] class User ( typesystem . Schema ): username = typesystem . String ( max_length = 100 ) is_admin = typesystem . Boolean ( default = False ) async def list_users ( request ): return JSONResponse ({ \"users\" : [ dict ( user ) for user in users ]}) async def add_user ( request ): data = await request . json () user , errors = User . validate_or_error ( data ) if errors : return JSONResponse ( dict ( errors ), status_code = 400 ) users . append ( user ) return JSONResponse ( dict ( user )) app = Starlette ( routes = [ Route ( '/' , list_users , methods = [ \"GET\" ]), Route ( '/' , add_user , methods = [ \"POST\" ]), ]) if __name__ == \"__main__\" : uvicorn . run ( app ) Form rendering app.py from starlette.applications import Starlette from starlette.routing import Route , Mount from starlette.staticfiles import StaticFiles from starlette.templating import Jinja2Templates import typesystem import uvicorn forms = typesystem . Jinja2Forms ( package = \"bootstrap4\" ) templates = Jinja2Templates ( directory = \"templates\" ) statics = StaticFiles ( packages = [ \"bootstrap4\" ]) users = [] class User ( typesystem . Schema ): username = typesystem . String ( max_length = 100 ) is_admin = typesystem . Boolean ( default = False ) async def homepage ( request ): form = forms . Form ( User ) return templates . TemplateResponse ( 'index.html' , { 'users' : users , 'form' : form }) async def add_user ( request ): data = await request . form () user , errors = User . validate_or_error ( data ) if errors : form = forms . Form ( User , values = data , errors = errors ) return templates . TemplateResponse ( 'index.html' , { 'form' : form }, status_code = 400 ) users . append ( user ) return RedirectResponse ( url = request . url_for ( 'homepage' )) app = Starlette ( routes = [ Route ( '/' , homepage , methods = [ 'GET' ]), Route ( '/' , add_user , methods = [ 'POST' ]), Mount ( '/static' , app = statics , name = 'static' ) ]) if __name__ == \"__main__\" : uvicorn . run ( app ) templates/index.html","title":"Examples"},{"location":"examples/#api-validation-serialization","text":"from starlette.applications import Starlette from starlette.responses import JSONResponse from starlette.routing import Route import typesystem import uvicorn users = [] class User ( typesystem . Schema ): username = typesystem . String ( max_length = 100 ) is_admin = typesystem . Boolean ( default = False ) async def list_users ( request ): return JSONResponse ({ \"users\" : [ dict ( user ) for user in users ]}) async def add_user ( request ): data = await request . json () user , errors = User . validate_or_error ( data ) if errors : return JSONResponse ( dict ( errors ), status_code = 400 ) users . append ( user ) return JSONResponse ( dict ( user )) app = Starlette ( routes = [ Route ( '/' , list_users , methods = [ \"GET\" ]), Route ( '/' , add_user , methods = [ \"POST\" ]), ]) if __name__ == \"__main__\" : uvicorn . run ( app )","title":"API validation &amp; serialization"},{"location":"examples/#form-rendering","text":"app.py from starlette.applications import Starlette from starlette.routing import Route , Mount from starlette.staticfiles import StaticFiles from starlette.templating import Jinja2Templates import typesystem import uvicorn forms = typesystem . Jinja2Forms ( package = \"bootstrap4\" ) templates = Jinja2Templates ( directory = \"templates\" ) statics = StaticFiles ( packages = [ \"bootstrap4\" ]) users = [] class User ( typesystem . Schema ): username = typesystem . String ( max_length = 100 ) is_admin = typesystem . Boolean ( default = False ) async def homepage ( request ): form = forms . Form ( User ) return templates . TemplateResponse ( 'index.html' , { 'users' : users , 'form' : form }) async def add_user ( request ): data = await request . form () user , errors = User . validate_or_error ( data ) if errors : form = forms . Form ( User , values = data , errors = errors ) return templates . TemplateResponse ( 'index.html' , { 'form' : form }, status_code = 400 ) users . append ( user ) return RedirectResponse ( url = request . url_for ( 'homepage' )) app = Starlette ( routes = [ Route ( '/' , homepage , methods = [ 'GET' ]), Route ( '/' , add_user , methods = [ 'POST' ]), Mount ( '/static' , app = statics , name = 'static' ) ]) if __name__ == \"__main__\" : uvicorn . run ( app ) templates/index.html","title":"Form rendering"},{"location":"fields/","text":"Overview Fields are usually declared as attributes on schema classes: class Organisation ( typesystem . Schema ): name = typesystem . String ( title = \"Name\" , max_length = 100 ) date_created = typesystem . Date ( title = \"Date created\" , default = datetime . date . today ) owner = typesystem . Nested ( title = \"Owner\" , schema = User , allow_null = True ) Fields are always required in inputs, unless a default value is set. Setting allow_null to True will set the default to None . (Unless default is already set.) Setting allow_blank to True will set the default to \"\" . (Unless default or allow_null is already set.) All fields support the following arguments. Arguments : title - A string to use when labelling the input. Default: None description - A string describing the input. Default: None default - A value to be used if no input is provided for this field. May be a callable, such as datetime.datetime.now . Default: NO_DEFAULT allow_null - A boolean determining if None values are valid. Default: False Using fields directly You can use fields to validate data directly, rather than using them on a schema class. This is useful if you have a general datastructure that requires validation. For instance, we could validate a dictionary of integers, like so: validator = typesystem . Object ( properties = typesystem . Integer ()) value = validator . validate ( data ) # May raise `ValidationError` Or returning a two-tuple of (value, ValidationError) : validator = typesystem . Object ( properties = typesystem . Integer ()) value , error = validator . validate_or_error ( data ) if error : ... else : ... Textual data types String Validates single-line text inputs. For example: username = typesystem.String(max_length=100) Arguments : allow_blank - A boolean indicating if the empty string should validate. Default: False max_length - A maximum number of characters that valid input stings may contain. Default: None min_length - A minimum number of characters that valid input stings may contain. Default: None pattern - A string to be used as a regex that must match. Eg. patern=\"^[A-Za-z]+$\" Default: None format - TODO Text Validates multi-line strings. Takes the same arguments as String . Represented in HTML forms as a <textarea> . Boolean data types Boolean Represented in HTML forms as a <checkbox> . For example: is_admin = typesystem.Boolean(default=False) Numeric data types Number A base class for Integer , Float , and Decimal . If used directly, Number will validate either int or float instances. Arguments : minimum - A number representing the minimum allowed value. Inputs must be greater than or equal to this to validate. Default: None maximum - A number representing the maximum allowed value. Inputs must be less than or equal to this to validate. Default: None exclusive_minimum - A number representing an exclusive minimum. Inputs must be greater than this to validate. Default: None exclusive_maximum - A number representing an exclusive maximum. Inputs must be less than this to validate. Default: None precision - A string representing the decimal precision to truncate input with. Eg. precision=\"0.001\" . Default: None multiple_of - A number giving a value that inputs must be a strict multiple of in order to validate. Eg. multiple_of=2 will only validate even integers. Integer Takes the same arguments as Number . Returns instances of int . Float Takes the same arguments as Number . Returns instances of float . Decimal Takes the same arguments as Number . Returns instances of decimal.Decimal . Enumeration data types Choice Arguments : choices - A list of two-tuples of (choice, description) . Default: None Date and time data types Date Time DateTime Composite data types Array Used to validate a list of data. For example: ratings = typesystem . Array ( items = typesystem . Integer ( min_value = 0 , max_value = 10 )) Arguments : items - Either a Field , used to validate each item in the list. Or a list of Field instances, used to validate each item in the list, positionally. Default: None additional_items - Only valid if items is a list. Either True or False , or a Field . Used to validate each additional item in the list. Default: False min_items - An integer, indicating the minimum number of items that must be present in the list. Default: None max_items - An integer, indicating the maximum number of items that may be present in the list. Default: None exact_items - An integer, indicating the exact number of items that must be present in the list. Default: None unique_items - A boolean. Used to determine if duplicate items are allowed in the list. Default: False Object Arguments : properties pattern_properties additional_properties min_properties max_properties required Nested schema - A schema class. Required Custom field types","title":"Fields"},{"location":"fields/#overview","text":"Fields are usually declared as attributes on schema classes: class Organisation ( typesystem . Schema ): name = typesystem . String ( title = \"Name\" , max_length = 100 ) date_created = typesystem . Date ( title = \"Date created\" , default = datetime . date . today ) owner = typesystem . Nested ( title = \"Owner\" , schema = User , allow_null = True ) Fields are always required in inputs, unless a default value is set. Setting allow_null to True will set the default to None . (Unless default is already set.) Setting allow_blank to True will set the default to \"\" . (Unless default or allow_null is already set.) All fields support the following arguments. Arguments : title - A string to use when labelling the input. Default: None description - A string describing the input. Default: None default - A value to be used if no input is provided for this field. May be a callable, such as datetime.datetime.now . Default: NO_DEFAULT allow_null - A boolean determining if None values are valid. Default: False","title":"Overview"},{"location":"fields/#using-fields-directly","text":"You can use fields to validate data directly, rather than using them on a schema class. This is useful if you have a general datastructure that requires validation. For instance, we could validate a dictionary of integers, like so: validator = typesystem . Object ( properties = typesystem . Integer ()) value = validator . validate ( data ) # May raise `ValidationError` Or returning a two-tuple of (value, ValidationError) : validator = typesystem . Object ( properties = typesystem . Integer ()) value , error = validator . validate_or_error ( data ) if error : ... else : ...","title":"Using fields directly"},{"location":"fields/#textual-data-types","text":"","title":"Textual data types"},{"location":"fields/#string","text":"Validates single-line text inputs. For example: username = typesystem.String(max_length=100) Arguments : allow_blank - A boolean indicating if the empty string should validate. Default: False max_length - A maximum number of characters that valid input stings may contain. Default: None min_length - A minimum number of characters that valid input stings may contain. Default: None pattern - A string to be used as a regex that must match. Eg. patern=\"^[A-Za-z]+$\" Default: None format - TODO","title":"String"},{"location":"fields/#text","text":"Validates multi-line strings. Takes the same arguments as String . Represented in HTML forms as a <textarea> .","title":"Text"},{"location":"fields/#boolean-data-types","text":"","title":"Boolean data types"},{"location":"fields/#boolean","text":"Represented in HTML forms as a <checkbox> . For example: is_admin = typesystem.Boolean(default=False)","title":"Boolean"},{"location":"fields/#numeric-data-types","text":"","title":"Numeric data types"},{"location":"fields/#number","text":"A base class for Integer , Float , and Decimal . If used directly, Number will validate either int or float instances. Arguments : minimum - A number representing the minimum allowed value. Inputs must be greater than or equal to this to validate. Default: None maximum - A number representing the maximum allowed value. Inputs must be less than or equal to this to validate. Default: None exclusive_minimum - A number representing an exclusive minimum. Inputs must be greater than this to validate. Default: None exclusive_maximum - A number representing an exclusive maximum. Inputs must be less than this to validate. Default: None precision - A string representing the decimal precision to truncate input with. Eg. precision=\"0.001\" . Default: None multiple_of - A number giving a value that inputs must be a strict multiple of in order to validate. Eg. multiple_of=2 will only validate even integers.","title":"Number"},{"location":"fields/#integer","text":"Takes the same arguments as Number . Returns instances of int .","title":"Integer"},{"location":"fields/#float","text":"Takes the same arguments as Number . Returns instances of float .","title":"Float"},{"location":"fields/#decimal","text":"Takes the same arguments as Number . Returns instances of decimal.Decimal .","title":"Decimal"},{"location":"fields/#enumeration-data-types","text":"","title":"Enumeration data types"},{"location":"fields/#choice","text":"Arguments : choices - A list of two-tuples of (choice, description) . Default: None","title":"Choice"},{"location":"fields/#date-and-time-data-types","text":"","title":"Date and time data types"},{"location":"fields/#date","text":"","title":"Date"},{"location":"fields/#time","text":"","title":"Time"},{"location":"fields/#datetime","text":"","title":"DateTime"},{"location":"fields/#composite-data-types","text":"","title":"Composite data types"},{"location":"fields/#array","text":"Used to validate a list of data. For example: ratings = typesystem . Array ( items = typesystem . Integer ( min_value = 0 , max_value = 10 )) Arguments : items - Either a Field , used to validate each item in the list. Or a list of Field instances, used to validate each item in the list, positionally. Default: None additional_items - Only valid if items is a list. Either True or False , or a Field . Used to validate each additional item in the list. Default: False min_items - An integer, indicating the minimum number of items that must be present in the list. Default: None max_items - An integer, indicating the maximum number of items that may be present in the list. Default: None exact_items - An integer, indicating the exact number of items that must be present in the list. Default: None unique_items - A boolean. Used to determine if duplicate items are allowed in the list. Default: False","title":"Array"},{"location":"fields/#object","text":"Arguments : properties pattern_properties additional_properties min_properties max_properties required","title":"Object"},{"location":"fields/#nested","text":"schema - A schema class. Required","title":"Nested"},{"location":"fields/#custom-field-types","text":"","title":"Custom field types"},{"location":"forms/","text":"TODO","title":"Forms"},{"location":"schemas/","text":"Let's start by defining some schema classes. import typesystem class Artist ( typesystem . Schema ): name = typesystem . String ( max_length = 100 ) class Album ( typesystem . Schema ): title = typesystem . String ( max_length = 100 ) release_date = typesystem . Date () artist = typesystem . Nested ( Artist ) We've got some incoming user data that we'd like to validate against our schema. data = { 'title' : 'Double Negative' , 'release_date' : '2018-09-14' , 'artist' : { 'name' : 'Low' } } We can validate the data against a Schema by using .validate(data) . album = Album . validate ( data ) If validation succeeds, this will return an Album instance. If validation fails, a ValidationError will be raised. Alternatively we can use .validate_or_error(data) , which will return a two-tuple of (value, error) . Either one of value or error will be None . album , error = Album . validate_or_error ( data ) if error : ... else : ... Working with validation errors The ValidationError class presents a dict-like interface: invalid_data = { 'title' : 'Double Negative' , 'release_date' : '2018.09.14' , 'artist' : { 'name' : 'x' * 1000 } } album , error = Album . validate_or_error ( invalid_data ) print ( dict ( error )) # {'release_date': 'Must be a valid date format.', 'artist': {'name': 'Must have no more than 100 characters.'}} print ( list ( error . keys ())) # ['release_date', 'artist'] If you want more precise information about exactly what error messages exist, you can access each individual message with error.messages() : album , error = Album . validate_or_error ( invalid_data ) for message in error . messages (): print ( f '{message.index!r}, {message.code!r}, {message.text!r})' ) # ['release_date'], 'format', 'Must be a valid date format.' # ['artist', 'name'], 'max_length', 'Must have no more than 100 characters.' Working with schema instances Schema instances are returned by calls to .validate() . data = { 'title' : 'Double Negative' , 'release_date' : '2018-09-14' , 'artist' : { 'name' : 'Low' } } album = Album . validate ( data ) print ( album ) # Album(title='Double Negative', release_date=datetime.date(2018, 9, 14), artist=Artist(name='Low')) Attributes on schemas return native python data types. print ( type ( album . release_date )) # <class 'datetime.date'> Schema instances present a dict-like interface, allowing them to be easily serialized. print ( dict ( album )) # {'title': 'Double Negative', 'release_date': '2018-09-14', 'artist': {'name': 'Low'}} Index lookup on schema instances returns serialized datatypes. print ( type ( album . release_date )) # <class 'str'> You can also instantiate schema instances directly. artist = Artist ( name = 'Low' ) album = Album ( title = 'Double Negative' , release_date = '2018-09-14' , artist = artist ) When instantiating with keyword arguments, each keyword argument will be validated. If instantiated directly, schema instances may be sparsely populated. Any unused attributes without a default will not be set on the instance. artist = Artist ( name = 'Low' ) album = Album ( title = 'Double Negative' , artist = artist ) print ( album ) # Album(title='Double Negative', artist=Artist(name='Low')) [sparse] album . release_date # AttributeError: 'Album' object has no attribute 'release_date' print ( dict ( album )) { 'title' : 'Double Negative' , 'artist' : { 'name' : 'Low' }} Sparsely populated instances can be useful for cases of loading data from database, when you do not need to retrieve all the fields, or for cases of loading nested data where no database join has been made, and only the primary key of the relationship is known. You can also instantiate a schema from an object instance or dictionary. new_album = Album ( album ) Note that data validation is not applied when instantiating a schema instance directly from an instance or dictionary. This should be used when creating instances against a data source that is already known to be validated, such as when loading existing instances from a database.","title":"Schemas"},{"location":"schemas/#working-with-validation-errors","text":"The ValidationError class presents a dict-like interface: invalid_data = { 'title' : 'Double Negative' , 'release_date' : '2018.09.14' , 'artist' : { 'name' : 'x' * 1000 } } album , error = Album . validate_or_error ( invalid_data ) print ( dict ( error )) # {'release_date': 'Must be a valid date format.', 'artist': {'name': 'Must have no more than 100 characters.'}} print ( list ( error . keys ())) # ['release_date', 'artist'] If you want more precise information about exactly what error messages exist, you can access each individual message with error.messages() : album , error = Album . validate_or_error ( invalid_data ) for message in error . messages (): print ( f '{message.index!r}, {message.code!r}, {message.text!r})' ) # ['release_date'], 'format', 'Must be a valid date format.' # ['artist', 'name'], 'max_length', 'Must have no more than 100 characters.'","title":"Working with validation errors"},{"location":"schemas/#working-with-schema-instances","text":"Schema instances are returned by calls to .validate() . data = { 'title' : 'Double Negative' , 'release_date' : '2018-09-14' , 'artist' : { 'name' : 'Low' } } album = Album . validate ( data ) print ( album ) # Album(title='Double Negative', release_date=datetime.date(2018, 9, 14), artist=Artist(name='Low')) Attributes on schemas return native python data types. print ( type ( album . release_date )) # <class 'datetime.date'> Schema instances present a dict-like interface, allowing them to be easily serialized. print ( dict ( album )) # {'title': 'Double Negative', 'release_date': '2018-09-14', 'artist': {'name': 'Low'}} Index lookup on schema instances returns serialized datatypes. print ( type ( album . release_date )) # <class 'str'> You can also instantiate schema instances directly. artist = Artist ( name = 'Low' ) album = Album ( title = 'Double Negative' , release_date = '2018-09-14' , artist = artist ) When instantiating with keyword arguments, each keyword argument will be validated. If instantiated directly, schema instances may be sparsely populated. Any unused attributes without a default will not be set on the instance. artist = Artist ( name = 'Low' ) album = Album ( title = 'Double Negative' , artist = artist ) print ( album ) # Album(title='Double Negative', artist=Artist(name='Low')) [sparse] album . release_date # AttributeError: 'Album' object has no attribute 'release_date' print ( dict ( album )) { 'title' : 'Double Negative' , 'artist' : { 'name' : 'Low' }} Sparsely populated instances can be useful for cases of loading data from database, when you do not need to retrieve all the fields, or for cases of loading nested data where no database join has been made, and only the primary key of the relationship is known. You can also instantiate a schema from an object instance or dictionary. new_album = Album ( album ) Note that data validation is not applied when instantiating a schema instance directly from an instance or dictionary. This should be used when creating instances against a data source that is already known to be validated, such as when loading existing instances from a database.","title":"Working with schema instances"}]}