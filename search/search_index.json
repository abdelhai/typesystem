{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"TypeSystem TypeSystem is a comprehensive data validation library that gives you: Data validation. Object serialization & deserialization. Form rendering. 100% type annotated codebase. 100% test coverage. Zero hard dependencies. Requirements Python 3.6+ Installation $ pip3 install typesystem If you'd like you use the form rendering you'll also want to install jinja2 . $ pip3 install jinja2 Quickstart import typesystem class Artist ( typesystem . Schema ): name = typesystem . String ( max_length = 100 ) class Album ( typesystem . Schema ): title = typesystem . String ( max_length = 100 ) release_date = typesystem . Date () artist = typesystem . Nested ( Artist ) album = Album . validate ({ \"title\" : \"Double Negative\" , \"release_date\" : \"2018-09-14\" , \"artist\" : { \"name\" : \"Low\" } }) print ( album ) # Album(title='Double Negative', release_date=datetime.date(2018, 9, 14), artist=Artist(name='Low')) print ( album . release_date ) # datetime.date(2018, 9, 14) print ( album [ 'release_date' ]) # '2018-09-14' print ( dict ( album )) # {'title': 'Double Negative', 'release_date': '2018-09-14', 'artist': {'name': 'Low'}} \u2014 \u2b50\ufe0f \u2014 TypeSystem is BSD licensed code. Designed & built in Brighton, England.","title":"Introduction"},{"location":"#typesystem","text":"TypeSystem is a comprehensive data validation library that gives you: Data validation. Object serialization & deserialization. Form rendering. 100% type annotated codebase. 100% test coverage. Zero hard dependencies.","title":"TypeSystem"},{"location":"#requirements","text":"Python 3.6+","title":"Requirements"},{"location":"#installation","text":"$ pip3 install typesystem If you'd like you use the form rendering you'll also want to install jinja2 . $ pip3 install jinja2","title":"Installation"},{"location":"#quickstart","text":"import typesystem class Artist ( typesystem . Schema ): name = typesystem . String ( max_length = 100 ) class Album ( typesystem . Schema ): title = typesystem . String ( max_length = 100 ) release_date = typesystem . Date () artist = typesystem . Nested ( Artist ) album = Album . validate ({ \"title\" : \"Double Negative\" , \"release_date\" : \"2018-09-14\" , \"artist\" : { \"name\" : \"Low\" } }) print ( album ) # Album(title='Double Negative', release_date=datetime.date(2018, 9, 14), artist=Artist(name='Low')) print ( album . release_date ) # datetime.date(2018, 9, 14) print ( album [ 'release_date' ]) # '2018-09-14' print ( dict ( album )) # {'title': 'Double Negative', 'release_date': '2018-09-14', 'artist': {'name': 'Low'}} \u2014 \u2b50\ufe0f \u2014 TypeSystem is BSD licensed code. Designed & built in Brighton, England.","title":"Quickstart"},{"location":"examples/","text":"The following are examples of integrating typesystem against a Web framework. API validation & serialization from starlette.applications import Starlette from starlette.responses import JSONResponse from starlette.routing import Route import typesystem import uvicorn users = [] class User ( typesystem . Schema ): username = typesystem . String ( max_length = 100 ) is_admin = typesystem . Boolean ( default = False ) async def list_users ( request ): return JSONResponse ({ \"users\" : [ dict ( user ) for user in users ]}) async def add_user ( request ): data = await request . json () user , errors = User . validate_or_error ( data ) if errors : return JSONResponse ( dict ( errors ), status_code = 400 ) users . append ( user ) return JSONResponse ( dict ( user )) app = Starlette ( routes = [ Route ( '/' , list_users , methods = [ \"GET\" ]), Route ( '/' , add_user , methods = [ \"POST\" ]), ]) if __name__ == \"__main__\" : uvicorn . run ( app ) Form rendering app.py from starlette.applications import Starlette from starlette.routing import Route , Mount from starlette.staticfiles import StaticFiles from starlette.templating import Jinja2Templates import typesystem import uvicorn forms = typesystem . Jinja2Forms ( package = \"bootstrap4\" ) templates = Jinja2Templates ( directory = \"templates\" ) statics = StaticFiles ( packages = [ \"bootstrap4\" ]) users = [] class User ( typesystem . Schema ): username = typesystem . String ( max_length = 100 ) is_admin = typesystem . Boolean ( default = False ) async def homepage ( request ): form = forms . Form ( User ) return templates . TemplateResponse ( 'index.html' , { 'users' : users , 'form' : form }) async def add_user ( request ): data = await request . form () user , errors = User . validate_or_error ( data ) if errors : form = forms . Form ( User , values = data , errors = errors ) return templates . TemplateResponse ( 'index.html' , { 'form' : form }, status_code = 400 ) users . append ( user ) return RedirectResponse ( url = request . url_for ( 'homepage' )) app = Starlette ( routes = [ Route ( '/' , homepage , methods = [ 'GET' ]), Route ( '/' , add_user , methods = [ 'POST' ]), Mount ( '/static' , app = statics , name = 'static' ) ]) if __name__ == \"__main__\" : uvicorn . run ( app ) templates/index.html","title":"Examples"},{"location":"examples/#api-validation-serialization","text":"from starlette.applications import Starlette from starlette.responses import JSONResponse from starlette.routing import Route import typesystem import uvicorn users = [] class User ( typesystem . Schema ): username = typesystem . String ( max_length = 100 ) is_admin = typesystem . Boolean ( default = False ) async def list_users ( request ): return JSONResponse ({ \"users\" : [ dict ( user ) for user in users ]}) async def add_user ( request ): data = await request . json () user , errors = User . validate_or_error ( data ) if errors : return JSONResponse ( dict ( errors ), status_code = 400 ) users . append ( user ) return JSONResponse ( dict ( user )) app = Starlette ( routes = [ Route ( '/' , list_users , methods = [ \"GET\" ]), Route ( '/' , add_user , methods = [ \"POST\" ]), ]) if __name__ == \"__main__\" : uvicorn . run ( app )","title":"API validation &amp; serialization"},{"location":"examples/#form-rendering","text":"app.py from starlette.applications import Starlette from starlette.routing import Route , Mount from starlette.staticfiles import StaticFiles from starlette.templating import Jinja2Templates import typesystem import uvicorn forms = typesystem . Jinja2Forms ( package = \"bootstrap4\" ) templates = Jinja2Templates ( directory = \"templates\" ) statics = StaticFiles ( packages = [ \"bootstrap4\" ]) users = [] class User ( typesystem . Schema ): username = typesystem . String ( max_length = 100 ) is_admin = typesystem . Boolean ( default = False ) async def homepage ( request ): form = forms . Form ( User ) return templates . TemplateResponse ( 'index.html' , { 'users' : users , 'form' : form }) async def add_user ( request ): data = await request . form () user , errors = User . validate_or_error ( data ) if errors : form = forms . Form ( User , values = data , errors = errors ) return templates . TemplateResponse ( 'index.html' , { 'form' : form }, status_code = 400 ) users . append ( user ) return RedirectResponse ( url = request . url_for ( 'homepage' )) app = Starlette ( routes = [ Route ( '/' , homepage , methods = [ 'GET' ]), Route ( '/' , add_user , methods = [ 'POST' ]), Mount ( '/static' , app = statics , name = 'static' ) ]) if __name__ == \"__main__\" : uvicorn . run ( app ) templates/index.html","title":"Form rendering"},{"location":"fields/","text":"title description default allow_null String allow_blank max_length min_length pattern format Text Boolean Numeric data types Number minimum - An integer representing the minimum allowed value. Default: None maximum - An integer representing the maximum allowed value. Default: None exclusive_minimum - An integer representing the minimum allowed value. Default: None exclusive_maximum precision - A string representing the decimal precision to truncate input with. Eg. precision=\"0.001\" . Default: None multiple_of Integer Float Decimal Enumeration data types Choice choices - May be any of the following: A list of choices. A dict of {choice: description} . A list of two-tuples of (choice, description) . Required Date and time data types Date Time DateTime Composite data types Array Used to validate a list of data. For example: ratings = typesystem . Array ( items = typesystem . Integer ( min_value = 0 , max_value = 10 )) Arguments : items - Either a Field , used to validate each item in the list. Or a list of Field instances, used to validate each item in the list, positionally. Default: None additional_items - Only valid if items is a list. Either True or False , or a Field . Used to validate each additional item in the list. Default: False min_items - An integer, indicating the minimum number of items that must be present in the list. Default: None max_items - An integer, indicating the maximum number of items that may be present in the list. Default: None exact_items - An integer, indicating the exact number of items that must be present in the list. Default: None unique_items - A boolean. Used to determine if duplicate items are allowed in the list. Default: False Object properties pattern_properties additional_properties min_properties max_properties required Nested schema - A schema class. Required Custom field types","title":"Fields"},{"location":"fields/#string","text":"allow_blank max_length min_length pattern format","title":"String"},{"location":"fields/#text","text":"","title":"Text"},{"location":"fields/#boolean","text":"","title":"Boolean"},{"location":"fields/#numeric-data-types","text":"","title":"Numeric data types"},{"location":"fields/#number","text":"minimum - An integer representing the minimum allowed value. Default: None maximum - An integer representing the maximum allowed value. Default: None exclusive_minimum - An integer representing the minimum allowed value. Default: None exclusive_maximum precision - A string representing the decimal precision to truncate input with. Eg. precision=\"0.001\" . Default: None multiple_of","title":"Number"},{"location":"fields/#integer","text":"","title":"Integer"},{"location":"fields/#float","text":"","title":"Float"},{"location":"fields/#decimal","text":"","title":"Decimal"},{"location":"fields/#enumeration-data-types","text":"","title":"Enumeration data types"},{"location":"fields/#choice","text":"choices - May be any of the following: A list of choices. A dict of {choice: description} . A list of two-tuples of (choice, description) . Required","title":"Choice"},{"location":"fields/#date-and-time-data-types","text":"","title":"Date and time data types"},{"location":"fields/#date","text":"","title":"Date"},{"location":"fields/#time","text":"","title":"Time"},{"location":"fields/#datetime","text":"","title":"DateTime"},{"location":"fields/#composite-data-types","text":"","title":"Composite data types"},{"location":"fields/#array","text":"Used to validate a list of data. For example: ratings = typesystem . Array ( items = typesystem . Integer ( min_value = 0 , max_value = 10 )) Arguments : items - Either a Field , used to validate each item in the list. Or a list of Field instances, used to validate each item in the list, positionally. Default: None additional_items - Only valid if items is a list. Either True or False , or a Field . Used to validate each additional item in the list. Default: False min_items - An integer, indicating the minimum number of items that must be present in the list. Default: None max_items - An integer, indicating the maximum number of items that may be present in the list. Default: None exact_items - An integer, indicating the exact number of items that must be present in the list. Default: None unique_items - A boolean. Used to determine if duplicate items are allowed in the list. Default: False","title":"Array"},{"location":"fields/#object","text":"properties pattern_properties additional_properties min_properties max_properties required","title":"Object"},{"location":"fields/#nested","text":"schema - A schema class. Required","title":"Nested"},{"location":"fields/#custom-field-types","text":"","title":"Custom field types"},{"location":"forms/","text":"TODO","title":"Forms"},{"location":"schemas/","text":"Let's start by defining some schema classes. import typesystem class Artist ( typesystem . Schema ): name = typesystem . String ( max_length = 100 ) class Album ( typesystem . Schema ): title = typesystem . String ( max_length = 100 ) release_date = typesystem . Date () artist = typesystem . Nested ( Artist ) We've got some incoming user data that we'd like to validate against our schema. data = { 'title' : 'Double Negative' , 'release_date' : '2018-09-14' , 'artist' : { 'name' : 'Low' } } We can validate the data against a Schema by using .validate(data) . album = Album . validate ( data ) If validation succeeds, this will return an Album instance. If validation fails, a ValidationError will be raised. Alternatively we can use .validate_or_error(data) , which will return a two-tuple of (value, error) . Either one of value or error will be None . album , error = Album . validate_or_error ( data ) if error : ... else : ... Working with validation errors The ValidationError class presents a dict-like interface: invalid_data = { 'title' : 'Double Negative' , 'release_date' : '2018.09.14' , 'artist' : { 'name' : 'x' * 1000 } } album , error = Album . validate_or_error ( invalid_data ) print ( dict ( error )) # {'release_date': 'Must be a valid date format.', 'artist': {'name': 'Must have no more than 100 characters.'}} print ( list ( error . keys ())) # ['release_date', 'artist'] If you want more precise information about exactly what error messages exist, you can access each individual message with error.messages() : album , error = Album . validate_or_error ( invalid_data ) for message in error . messages (): print ( f '* {message.index!r}, {message.code!r}, {message.text!r})' ) # ['release_date'], 'format', 'Must be a valid date format.' # ['artist', 'name'], 'max_length', 'Must have no more than 100 characters.' Working with schema instances Schema instances are returned by calls to .validate() . data = { 'title' : 'Double Negative' , 'release_date' : '2018-09-14' , 'artist' : { 'name' : 'Low' } } album = Album . validate ( data ) print ( album ) # Album(title='Double Negative', release_date=datetime.date(2018, 9, 14), artist=Artist(name='Low')) Attributes on schemas return native python data types. print ( type ( album . release_date )) # <class 'datetime.date'> Schema instances present a dict-like interface, allowing them to be easily serialized. print ( dict ( album )) # {'title': 'Double Negative', 'release_date': '2018-09-14', 'artist': {'name': 'Low'}} Index lookup on schema instances returns serialized datatypes. print ( type ( album . release_date )) # <class 'str'> You can also instantiate schema instances directly. artist = Artist ( name = 'Low' ) album = Album ( title = 'Double Negative' , release_date = '2018-09-14' , artist = artist ) When instantiating with keyword arguments, each keyword argument will be validated. If instantiated directly, schema instances may be sparsely populated. Any unused attributes without a default will not be set on the instance. artist = Artist ( name = 'Low' ) album = Album ( title = 'Double Negative' , artist = artist ) print ( album ) # Album(title='Double Negative', artist=Artist(name='Low')) [sparse] album . release_date # AttributeError: 'Album' object has no attribute 'release_date' print ( dict ( album )) { 'title' : 'Double Negative' , 'artist' : { 'name' : 'Low' }} Sparsely populated instances can be useful for cases of loading data from database, when you do not need to retrieve all the fields, or for cases of loading nested data where no database join has been made, and only the primary key of the relationship is known. You can also instantiate a schema from an object instance or dictionary. new_album = Album ( album ) Note that data validation is not applied when instantiating a schema instance directly from an instance or dictionary. This should be used when creating instances against a data source that is already known to be validated, such as when loading existing instances from a database.","title":"Schemas"},{"location":"schemas/#working-with-validation-errors","text":"The ValidationError class presents a dict-like interface: invalid_data = { 'title' : 'Double Negative' , 'release_date' : '2018.09.14' , 'artist' : { 'name' : 'x' * 1000 } } album , error = Album . validate_or_error ( invalid_data ) print ( dict ( error )) # {'release_date': 'Must be a valid date format.', 'artist': {'name': 'Must have no more than 100 characters.'}} print ( list ( error . keys ())) # ['release_date', 'artist'] If you want more precise information about exactly what error messages exist, you can access each individual message with error.messages() : album , error = Album . validate_or_error ( invalid_data ) for message in error . messages (): print ( f '* {message.index!r}, {message.code!r}, {message.text!r})' ) # ['release_date'], 'format', 'Must be a valid date format.' # ['artist', 'name'], 'max_length', 'Must have no more than 100 characters.'","title":"Working with validation errors"},{"location":"schemas/#working-with-schema-instances","text":"Schema instances are returned by calls to .validate() . data = { 'title' : 'Double Negative' , 'release_date' : '2018-09-14' , 'artist' : { 'name' : 'Low' } } album = Album . validate ( data ) print ( album ) # Album(title='Double Negative', release_date=datetime.date(2018, 9, 14), artist=Artist(name='Low')) Attributes on schemas return native python data types. print ( type ( album . release_date )) # <class 'datetime.date'> Schema instances present a dict-like interface, allowing them to be easily serialized. print ( dict ( album )) # {'title': 'Double Negative', 'release_date': '2018-09-14', 'artist': {'name': 'Low'}} Index lookup on schema instances returns serialized datatypes. print ( type ( album . release_date )) # <class 'str'> You can also instantiate schema instances directly. artist = Artist ( name = 'Low' ) album = Album ( title = 'Double Negative' , release_date = '2018-09-14' , artist = artist ) When instantiating with keyword arguments, each keyword argument will be validated. If instantiated directly, schema instances may be sparsely populated. Any unused attributes without a default will not be set on the instance. artist = Artist ( name = 'Low' ) album = Album ( title = 'Double Negative' , artist = artist ) print ( album ) # Album(title='Double Negative', artist=Artist(name='Low')) [sparse] album . release_date # AttributeError: 'Album' object has no attribute 'release_date' print ( dict ( album )) { 'title' : 'Double Negative' , 'artist' : { 'name' : 'Low' }} Sparsely populated instances can be useful for cases of loading data from database, when you do not need to retrieve all the fields, or for cases of loading nested data where no database join has been made, and only the primary key of the relationship is known. You can also instantiate a schema from an object instance or dictionary. new_album = Album ( album ) Note that data validation is not applied when instantiating a schema instance directly from an instance or dictionary. This should be used when creating instances against a data source that is already known to be validated, such as when loading existing instances from a database.","title":"Working with schema instances"}]}